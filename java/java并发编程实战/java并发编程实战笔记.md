### 第一章

#### 线程带来的问题

* 安全性问题：多个线程对一个共享变量进行操作，没有协同。典型的，多个线程同时对同一变量做自增操作。
* 活跃性问题：这个问题单线程环境下也会有，比如出现死循环，导致后面的代码无法执行。在多线程环境下会有其他活跃性问题，比如线程A等待线程B释放资源，但是B永远不释放资源，A就会永远等待；再比如喜闻乐见的死锁问题等等都是活跃性问题。
* 性能问题：线程切换调度的开销、线程协同时的同步机制抑制某些编译器优化等。

#### 框架带来的线程安全问题

* Timer类：作用是使一个任务在一定时间后执行，或周期性执行。这些任务（TimerTask）将在Timer管理的线程中执行，不由应用程序管理。所以TimerTask应以线程安全的方式访问共享数据。
* Servlet：可能出现多个请求（也就是多个线程）同时调用一个Servlet的情况。所以Servlet本身要是线程安全的，且Servlet要以线程安全的方式访问和其他Servlet共享的对象，比如会话中的对象。
* 远程方法调用（RMI）：RMI对象可能会在多个线程中被调用，且这些线程不由应用程序管理，所以要求RMI对象本身是线程安全的。远程对象可能会同时收到多个远程调用请求，所以远程对象也要是线程安全的。

### 第二章

* 需要考虑线程同步的情况：某个对象的状态是共享的且是可变的。
* 具有良好的封装性和不变性的类更容易设计为线程安全类。
* 对于并发应用程序，**优先保证代码的正确性，再考虑性能**。

#### 线程安全性

* 定义：当多个线程访问某个类时，不管这些线程如何交替执行，且主调代码中不需要任何额外的同步，这个类都能有正确的行为，那么这个类是线程安全的。
* 线程安全类中封装了必要的同步机制，因此客户端不需要额外的同步措施。
* 无状态的对象一定是线程安全的。

#### 原子性

* 竞态条件：基于一种可能失效的观察结果来决定下一步行动。
* 竞态条件的几种典型情况：
  * 读取-修改-写回
  * 先检查后执行
* 要避免竞态条件就要将构成竞态条件的一系列操作作为一个原子操作进行。
* 如果一个对象只有一个状态，且该状态由一个线程安全对象管理，则该对象是线程安全的。所以应尽可能使用现有的线程安全对象来管理类的状态。

#### 加锁机制

* 若一个对象内部有一组关联的状态（可互相约束），只要涉及到其中一个状态的更新，就要在一个原子操作中更新所有与之关联的状态。获取两个以上关联的状态也要在一个原子操作中进行。
* 内置锁（监视锁）：synchronized代码块用到的锁，可以是任意java对象。内置锁是一种互斥锁，这种锁有一个严重问题，就是并发性能非常差。
* 内置锁是可重入的，也就是说如果一个线程尝试获得一个自己已经持有的锁，一定会成功。重入的一种实现方式是为每个锁关联一个计数值和所有者线程。当计数值为0，认为该锁没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者并将计数值置为1。如果同一个线程再次获取该锁，计数值递增。线程退出同步代码块，计数器递减。计数值为0时，锁将被释放。

#### 用锁来保护状态

* 对于共享、可变且非线程安全的状态，无论何时何地访问它，都必须要持有**同一个锁**，这个锁称为该状态的保护锁。对于一组关联的状态，它们的保护锁必须是同一个。

#### 活跃性与性能

* 同步代码块不宜过长和过短，过长将影响并发性能。将一段同步代码块分解得过细将导致频繁获取锁释放锁，会影响性能和代码的简单性。
* 计算密集型的操作和可能会阻塞的操作不要放在同步代码块中。持有锁的时间过长将导致活跃性与性能问题。

### 第三章

#### 可见性

* 失效数据：在缺乏同步的程序中，一个线程对共享变量的写入操作对另一个线程可能不是立即可见的，读线程读到的数据不是最新版本，或者说是失效的。
* 线程读到的数据虽然说可能是失效的，但至少可以保证是之前的某个旧版本的数据，这种保证称为最低安全性。
* 最低安全性适用于绝大多数类型的变量，但非volatile类型的64位数值类型（long和double）例外，因为long的double的读取和写入操作不是原子操作，而是分解为两次32位操作。
* 线程A执行完某个同步代码块后，线程B进入由同一个锁保护的同步代码块，保证可以看到线程A之前的操作产生的结果。**内置锁不仅有互斥性保证，还有可见性保证**。
* volatile变量的读和写操作可以近似地看做同步的getter和setter方法，也可以将volatile关键字理解为一种比synchronized关键字更轻量级的同步机制。
* 线程A写入volatile变量随后线程B读取该变量，那么A写入之前对A可见的所有变量，在B读取后也对B可见。
* volatile变量的一种典型用法：作为某个操作完成、中断或其他状态的标志。
* synchronized既可以确保原子性也可以确保可见性，volatile变量只能确保可见性。
* volatile状态不应该与其他状态关联，不应该在同步代码块中访问。

#### 发布与逸出

* 发布：对象作用域之外的代码可以获取该对象的引用，称该对象是已发布的。基本类型变量不算对象，无法发布。
* 对象发布的几种方式：
  * 将对象直接公开。
  * 将对象共享给其他线程。
  * 将对象传递给外部方法或可重写方法。
  * 对象A依赖于对象B，A被发布导致B被连带发布。
* 逸出：某个不该发布的对象被发布时，称为逸出。逸出的对象有被误用的风险。
* this引用逸出：在构造器中发布this对象，这种现象称为不正确构造。
* this引用逸出的几种典型情况：
  * 在构造器中创建内部类对象并发布。
  * 在构造器中启动线程。
  * 在构造器中调用可重写的实例方法，相当于将this对象传递给一个不可控的方法。

#### 线程封闭

* 线程封闭：对象是线程私有的，这种情况称为对象封闭在该线程中。线程封闭可以保证线程安全，即使封闭的对象本身是非线程安全的。
* 线程封闭的几种方式：
  * 栈封闭：将对象作为局部变量使用，必须确保该对象不会被发布。基本类型的局部变量一定是封闭的。
  * ThreadLocal：将对象作为ThreadLocal变量使用，每个线程都会有一份该对象的独立副本。线程终止后，对应的ThreadLocal对象会作为垃圾回收。ThreadLocal技术不可滥用，一个典型的使用场景是某个频繁执行的操作（可能由多个线程执行）需要一个开销很大的临时对象（非线程安全），那么该临时对象就可以作为ThreadLocal变量。

#### 不变性

* 不可变对象一定线程安全。
* 需要同时读取或写入一组相关状态，可以在原子操作中进行，也可以将这一组相关状态封装到一个volatile不可变对象中。

#### 安全发布

* 不安全的发布可能会导致几点问题：
  * 其他线程看到的引用是一个失效值，比如空引用或之前的旧值。
  * 引用是最新的，但发布的对象的状态是失效的。因为Object的构造器会在子类构造器执行前将默认值写入所有域，此时对象引用对其他线程就是可见的，尽管构造器还未开始执行。也就是说状态的失效值其实是默认值。其实这种情况本质上和this引用逸出一样，构造器还未完成就发布了对象。
* final域的初始化安全保证：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了（不管这个final域是可变对象、不可变对象还是基本类型），而普通域就不具有这个保证。在有了这个保证的前提下，所有域都为final的正确构造的对象可以在没有额外措施的情况下安全发布。
* 安全发布的几种常用模式：
  * 通过静态初始化函数发布，比如`public static Subject s = new Subject(42);`。
  * 将对象保存为volatile域或保存到AtomicReferance对象中。
  * 将对象保存为由锁保护的域。
  * 将对象发布到线程安全容器中，可以安全发布给任何从这个容器中访问它的线程。
  * 将对象保存为一个正确构造的对象的final域（final域的初始化安全保证）。

### 第四章

#### 设计线程安全的类

* 设计线程安全类的过程中注意下面几点：
  * 找出构成对象状态的所有域。
  * 找出对象状态的所有约束。
  * 建立对象状态的并发访问管理策略。
* 对象的所有可能的状态构成该对象的状态空间，状态空间越小就越容易分析和设计。极端情况下不可变对象的状态只有一个。
* 状态的约束有两种：
  * 不变性条件：用于约束状态本身，比如数值类型的状态有一个取值范围。对于不变性条件，可以将相关状态封装为一个volatile不可变对象，也可以把相关状态的读写放在一个原子操作中进行。
  * 先验条件：用于约束状态的迁移，比如删除元素前，队列必须处于非空的状态。在并发程序中，要一直等到先验条件为真，然后再执行状态迁移。
  * 后验条件：用于约束状态的迁移，比如当前状态为1，下一个状态只能为2。有后验条件约束的状态迁移必须是原子性的。
* 当前对象可达的所有域的**子集**构成了该对象的状态。对象对自己拥有的状态具有控制权，比如状态的所有者可以决定采用何种加锁协议保护该状态。
* 容器内对象的状态不一定属于容器对象。

#### 实例封闭

* 实例封闭：将一个对象封装到另一个对象内部，能访问被封装对象的所有代码路径都是已知的，更易于分析代码。被封装对象不可以逸出到外界。
* 实例封闭可以将非线程安全类转化为线程安全类。
* java监视器模式：对象将所有可变状态封闭起来，并由该对象的内置锁或私有锁保护。私有锁好于对象自己的内置锁，因为后者是公开的，外部代码可以不受限制地使用。

#### 线程安全性的委托