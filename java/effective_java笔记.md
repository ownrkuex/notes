* 优先提供静态工厂方法，而不是构造器；优先使用静态工厂方法，而不是构造器。
* 尽早检测出程序中的错误。
* 单例模式的最佳写法是使用单个元素的枚举类型。
* 工具类要确保不可实例化。
* 在子类对象中引用父类对象很容易，super关键字就行了；在父类代码中引用子类对象，应使用模拟的self类型。
* 给定的对象去适配给定接口，只需要一个适配器对象，不要创建多个。
* 永远不要重写finalize()方法。
* 涉及到正则表达式只能用`Pattern.compile(..)`且Pattern对象一定要复用。
* 永远不要`new String("xxx")`。
* 永远不要`new Boolean(true)`和`new Boolean(false)`，用`Boolean.valueOf(..)`、`Boolean.TRUE`和`Boolean.FALSE`替代。
* 不要搞延迟初始化，性能提升不明显，且实现起来很复杂。
* 不要搞对象池，除非是重量级对象（数据库连接那种）。
* 对于AutoCloseable对象，必须要用try-with-resources关闭。try-with-resources不仅仅是try-catch-finally的语法糖，还压制（suppressed）了finally块中的异常，可通过真正的异常对象的getSuppressed()方法获得。

* 关于重写equals方法：
  * 五大约定：自反性、对称性、传递性、一致性和非空性。
  * 套路：
    1. `==`检查是否是同一对象。
    1. `instanceof`检查参数的类型是否是当前类型。
    1. 参数类型强转。
    1. 关键域比较：
       * float和double用`Float.compare(float, float)`和`Double.compare(double, double)`比较。
       * 其他基本类型域用`==`。
       * 对象引用域用`Objects.equals(Object, Object)`。
       * 数组域用Arrays.equals比较数组中的每个元素。
  * equals除非万不得已，不要重写。重写的类也不要有子类和父类，因为对称性和传递性牵扯到继承就会很麻烦。可以用组合代替继承。不要在不同类型的对象之间建立等价关系。

* 关于重写hashCode方法：
  * hashCode方法和equals方法要么同时重写，要么同时不重写。
  * 两个对象用equals方法比较是相等的，那么这两个对象的哈希码一定相等；如果是不相等的，那么这两个对象的哈希码应尽可能不相等，但相等也是有可能的。
  * 套路：
    1. 计算第一个关键域的哈希码，记为result。
    1. 计算剩下所有关键域的哈希码c，result = 31 * result + c。
    1. 返回最终result。
    关键域的哈希码计算有几种情况：
    * 基本类型域用`WrappedType.hashCode(value)`。
    * 对象引用域调用该域的hashCode方法。
    * 数组域视为多个关键域。
  * 对于不可变对象，应将哈希码缓存，而不是每次调用hashCode方法都重新计算一遍。可以在创建对象时计算一遍，也可以延迟初始化哈希码。

* 关于重写toString方法：
  * 尽量重写toString方法，用便于理解的方式展示对象包含的值得关注的信息，这样更易于调试。
  * 尽量在文档中详细说明toString方法返回值的格式。
  * 对toString方法返回的信息，应该要有其他简单直接的获取方式，尽可能避免对toString返回值的解析。
  * 不需要在枚举类中重写toString方法。

* 关于重写clone方法：
  * 绝大多数情况下不需要重写clone方法，拷贝构造器和拷贝工厂是更好的做法。
  * 浅拷贝数组的最佳做法是调用该数组对象的clone方法。
  * 套路：
    1. 实现Cloneable空接口。
    1. 重写clone方法，必须是公有的，返回类型为类本身。
    1. 通过`super.clone()`进行逐域拷贝。这样的调用链最终会调用Object中的native clone方法，也就是说，这种逐域拷贝是有风险的，java语言机制之外的。Object中的native clone方法的行为会受Cloneable接口影响，如果实现了Cloneable接口，会进行逐域拷贝，否则抛出CloneNotSupportedException。这是对接口的极端用法，不值得效仿。
    1. 修正任何需要修正的域（浅拷贝深拷贝问题）。

* 关于排序关系：
  * 当两个对象之间具有排序关系时，应考虑实现Comparable<T>接口。该接口只有一个方法`int compareTo(T t)`，约定是当前对象小于、等于或大于指定对象时返回负数、零或正数，且要尽量做到`(x.compareTo(y) == 0) == x.equals(y)`。
  * 当两个对象之间具有多种排序关系时，应考虑将主排序关系实现为Comparable<T>接口，将其他排序关系实现为Comparator<T>接口。该接口中的`int compare(T o1, T o2)`方法和compareTo方法具有类似的约定。
  * compareTo方法或compare方法的实现：从最重要的域开始比较，再比较次重要的域，以此类推，若某次比较出现不相等结果，则得出最终结果结束方法；若所有关键域的比较结果都是相等的，则返回0。对于基本类型域，应使用`WrappedType.compare(f1, f2)`比较；对于对象引用域，应视具体情况使用compareTo方法或Comparator对象进行比较；数组引用域视作多个对象引用域。

* 类和成员的可访问性应尽量最小化。
* 域不可以公开，但有两个特例：
  * 常量，且引用的对象不可变。
  * 类是包级私有的，或是私有的内部类。
* 对象中的集合域不可以直接访问，只能访问其视图（Collections.unmodifiableCollection系列方法）或拷贝（clone方法）。

* 构建不可变类的几点规则：
  * 没有任何方法能对对象状态产生外部可见的改变。
  * 类不可扩展。
  * 不能发布可变对象域，不要用客户端提供的对象引用初始化可变对象域。
  * 不可以this引用逸出。
* 不可变对象的优点：
  * 简单，只有一种状态，容易维护状态一致性。
  * 线程安全。
  * 高可用。可以把一些常用的不可变对象设为常量；可以提供工厂，把频繁请求的实例缓存起来。
  * 内部信息可以共享。
* 不可变对象的缺点：每个不同的值都需要一个单独的对象，如果产生大量不同的值或创建对象的开销很大，将导致性能问题。可以提供配套的可变类，比如String类有配套的StringBuilder类。
* 使类不可扩展可以把类声明为final，也可以把类的所有构造器变为私有或包级私有的并提供静态工厂方法。
* 对象应尽量降低其可变性。
* 不可变的域尽量声明为final。
* 尽量不要提供“重新初始化”方法。虽然这样可以复用对象，但一般来说性能优势不明显，却徒增复杂性。

* 可以使用继承的场合：
  * 子类和超类在同一个包下，在同一个程序员控制下。
  * 对于专门为了继承而设计且具有良好文档的类，可以继承它。
* 不可以使用继承的场合：对普通的具体类做跨包的继承。
* 适合使用继承的场合：两个类存在“is-a”关系。
* 不适合使用继承的场合：两个类没有“is-a”关系。
* 继承的缺点：
  * 破坏了封装性，使子类必须依赖超类的实现细节才能正常工作。
  * 子类直接修改超类，破坏子类的约束条件。
  * 超类API的缺陷会传播到子类中。
* 对于不适合或不可以使用继承的场合：
  * 不涉及多态：直接组合即可。
  * 涉及多态：转发类组合待扩展类，并实现同一个接口，包装类继承转发类。