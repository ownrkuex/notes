## 语句

多条语句写一行必须用分号隔开，一行一条语句可以不需要，但强烈建议加上。

## let

let和var类似，用于声明变量。和var的区别在于：

* let变量的作用域不会超过当前代码块（块级作用域）。
* var变量存在作用域提升现象，也就是说可以先使用后声明（作用域提升到全局），但let没有这种怪异现象，必须先声明再使用。
* 在for循环中用let声明循环变量，该变量只在**本次循环内有效**，也就是说，循环几次，就有几个i，这些i是不同的变量，互相独立互不影响。用var，不管循环几次，都只有一个i。

## 块级作用域

* 块级作用域内优先使用函数表达式，不使用函数声明语句：

  ```js
  {
      // 这是函数声明语句，块级作用域内不推荐使用
      function f() {
      }
  }
  {
      // 这是函数表达式，优先使用这种方式替代函数声明语句
      let f = function() {
      }
  }
  ```

* 块级作用域必须要有花括号，没有花括号就没有块级作用域。比如：

  ```js
  if (true) {
      console.log('这是一个块级作用域');
  }
  if (true)
      console.log('这里没有块级作用域！');
  ```

## const

const用于声明常量，声明后必须立刻初始化，不能留到以后赋值。const常量的作用域不会超过当前代码块（块级作用域）。const常量也必须先声明和初始化，才能使用。

## 顶层对象的属性

顶层对象是指window对象（它的另一个名字是self），用var声明一个全局变量，该变量将自动成为window对象的属性，但let变量和const常量不属于window对象。比如：

```js
var a = 1;
console.log(window.a); // 输出1
let b = 1;
console.log(window.b); // 输出undefined
const PI = 3.14;
console.log(window.PI); // 输出undefined
```

## 数组的解构赋值

ES6允许从数组和对象中批量提取和分发值，这一过程称为解构。比如：

```js
let nums = [1, 2];
let a = nums[0];
let b = nums[1];

// 解构做法
let [c, d] = nums; // c的值为1，d的值为2
```

上面的写法属于模式匹配，只要左右两边的结构相同，变量就会得到相同位置上的值。更多栗子：

```js
let [, a] = [1, 2];
a // 2
let [head, ...tail] = [1, 2, 3];
head // 1
tail // [2, 3]
```

如果两边结构不同，左边的变量在右边没有相同的位置，那么该变量就是undefined或[]。比如：

```js
let [a, b, ...c] = [1];
a // 1
b // undefined
c // []
```

两边结构不同的另一种情况是不完全解构：

```js
let [a, b] = [1, 2, 3];
a // 1
b // 2
let [a, [b], c] = [1, [2, 3], 4];
a // 1
b // 2
c // 4
```

如果右边是不可遍历的值（不具备Iterator接口），就会报错。注意空对象`{}`是不可遍历的。

### 默认值

解构赋值允许指定默认值：

```js
let [a = 1] = [];
a // 1
```

当右边相应位置的值`=== undefined`（严格等于undefined）时，默认值才会生效。如果默认值是个表达式，则只会在默认值生效的情况下计算。默认值可以引用解构赋值的其他变量，比如：

```js
let [a = 1, b = a] = [];
a // 1
b // 1
let [c = d, d = 1] = []; // ReferenceError：d未定义
```

## 对象的解构赋值

